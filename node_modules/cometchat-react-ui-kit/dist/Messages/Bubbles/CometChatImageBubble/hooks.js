"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Hooks = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _react = _interopRequireDefault(require("react"));

var _Shared = require("../../../Shared");

var _ = require("../../");

var _unsafeContent = _interopRequireDefault(require("./resources/unsafe-content.svg"));

var Hooks = function Hooks(props, setImageURL, imageURL, setUnsafe, setOverlayImage) {
  var errorHandler = function errorHandler(errorCode) {
    _.CometChatMessageEvents.emit(_.CometChatMessageEvents.onMessageError, errorCode);
  };

  var pickImage = function pickImage(thumbnailGenerationObject) {
    var smallUrl = thumbnailGenerationObject["url_small"];
    var mediumUrl = thumbnailGenerationObject["url_medium"];
    var mq = window.matchMedia("(min-width: 320px) and (max-width: 767px)");
    var imageToDownload = mediumUrl;

    if (mq.matches) {
      imageToDownload = smallUrl;
    }

    return imageToDownload;
  };

  _react.default.useEffect(function () {
    if (props && props.overlayImageURL) {
      setOverlayImage(props.overlayImageURL);
    } else {
      setOverlayImage(_unsafeContent.default);
    }
  }, [props, props.overlayImageURL]);

  var downloadImage = function downloadImage(imgUrl) {
    return new Promise(function (resolve, reject) {
      var timer;
      var xhr = new XMLHttpRequest();
      xhr.open("GET", imgUrl, true);
      xhr.responseType = "blob";

      xhr.onload = function () {
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            timer = null;
            resolve(imgUrl);
          } else if (xhr.status === 403) {
            timer = setTimeout(function () {
              downloadImage(imgUrl).then(function (response) {
                return resolve(imgUrl);
              }).catch(function (error) {
                return reject(error);
              });
            }, 800);
          }
        } else {
          reject(xhr.statusText);
        }
      };

      xhr.onerror = function (event) {
        return reject(new Error("There was a network error.", event));
      };

      xhr.ontimeout = function (event) {
        return reject(new Error("There was a timeout error.", event));
      };

      xhr.send();
    });
  };

  var setMessageImageUrl = _react.default.useCallback(function () {
    return new Promise(function (resolve) {
      var img = new Image();

      if (props.messageObject && props.messageObject.data && props.messageObject.data.attachments && (0, _typeof2.default)(props.messageObject.data.attachments) === "object" && props.messageObject.data.attachments.length) {
        var _props$messageObject$;

        img.src = (_props$messageObject$ = props.messageObject.data.attachments[0]) === null || _props$messageObject$ === void 0 ? void 0 : _props$messageObject$.url;
      } else if (props.messageObject.data.file && props.messageObject.data.file) {
        var reader = new FileReader();

        reader.onload = function () {
          img.src = reader.result;
        };

        reader.readAsDataURL(props.messageObject.data.file);
      }

      img.onload = function () {
        return resolve(img.src);
      };
    });
  }, [props.messageObject]);

  _react.default.useEffect(function () {
    if (props.imageURL && props.imageURL.length) {
      setImageURL(props.imageURL);
    } else if (props.messageObject) {
      var thumbnailGenerationExtensionData = (0, _Shared.getExtensionsData)(props.messageObject, _Shared.MetadataConstants.extensions.thumbnailGeneration);

      if (thumbnailGenerationExtensionData && !thumbnailGenerationExtensionData.hasOwnProperty("error")) {
        var imageToDownload = pickImage(thumbnailGenerationExtensionData);
        downloadImage(imageToDownload).then(function (response) {
          var img = new Image();
          img.src = imageToDownload;

          img.onload = function () {
            return setImageURL(img.src);
          };
        }).catch(function (error) {
          errorHandler(error);
          console.error(error);
        });
      } else {
        setMessageImageUrl().then(function (imageUrl) {
          if (imageUrl !== imageURL) {
            setImageURL(imageUrl);
          }
        });
      }
    }
  }, [imageURL, props.imageURL, props.messageObject, setImageURL, setMessageImageUrl]);

  _react.default.useEffect(function () {
    var imageModeration = (0, _Shared.getExtensionsData)(props === null || props === void 0 ? void 0 : props.messageObject, "image-moderation");

    if ((imageModeration === null || imageModeration === void 0 ? void 0 : imageModeration["unsafe"]) === "yes") {
      setUnsafe(true);
    } else {
      setUnsafe(false);
    }
  }, [props.messageObject]);
};

exports.Hooks = Hooks;