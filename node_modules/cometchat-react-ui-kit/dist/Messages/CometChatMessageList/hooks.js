"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchMessages = exports.Hooks = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _chat = require("@cometchat-pro/chat");

var _ = require("../..");

var _controller = require("./controller");

var _CometChatMessageTemplate = require("../CometChatMessageTemplate");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var fetchMessages = function fetchMessages(MessageListManager) {
  return new Promise(function (resolve, reject) {
    MessageListManager.fetchPreviousMessages().then(function (messageList) {
      return resolve(messageList);
    }).catch(function (error) {
      return reject(error);
    });
  });
};

exports.fetchMessages = fetchMessages;

var Hooks = function Hooks(limit, user, group, excludeMessageTypes, onlyUnread, hideDeletedMessages, hideMessagesFromBlockedUsers, tags, messageTypes, loggedInUserRef, messageList, setMessageList, setDecoratorMessage, setChatWith, setChatWithType, messageHandler, messageListCallback, handlers, callbackData, messageTypesRef, messageCategoryRef, messageListManagerRef, localize, errorHandler, chatWith, chatWithType, setMessageCount, setnewMessage) {
  _react.default.useEffect(function () {
    //fetching logged in user
    _chat.CometChat.getLoggedinUser().then(function (user) {
      var _messageListManagerRe;

      loggedInUserRef.current = _objectSpread({}, user); // 	// Setting MessageList ManagerRef if messageTypes is supplied by the user

      if (messageTypes) {
        if (messageTypes.length === 0) {
          return messageCategoryRef.current = [], messageTypesRef.current = [], setDecoratorMessage(localize("NO_MESSAGE_TYPE_SET"));
        } else {
          messageTypesRef.current = messageTypes.map(function (value) {
            return value.type;
          });
          messageCategoryRef.current = (0, _toConsumableArray2.default)(new Set(messageTypes.map(function (value) {
            return value.category;
          })));

          if (excludeMessageTypes && excludeMessageTypes.length) {
            messageTypesRef.current.filter(function (val) {
              return !excludeMessageTypes.includes(val);
            });
          }
        }
      } // Setting MessageList ManagerRef by default
      else {
        var messageTemplateObject = (0, _CometChatMessageTemplate.getDefaultTypes)();
        messageTypesRef.current = messageTemplateObject.map(function (value) {
          return value.type;
        });
        messageCategoryRef.current = (0, _toConsumableArray2.default)(new Set(messageTemplateObject.map(function (value) {
          return value.category;
        })));

        if (excludeMessageTypes && excludeMessageTypes.length) {
          messageTypesRef.current.filter(function (val) {
            return !excludeMessageTypes.includes(val);
          });
        }
      }

      messageListManagerRef.current = new _controller.MessageListManager(limit, user, group, onlyUnread, hideDeletedMessages, hideMessagesFromBlockedUsers, tags, messageTypesRef.current, messageCategoryRef.current);
      messageListManagerRef === null || messageListManagerRef === void 0 ? void 0 : (_messageListManagerRe = messageListManagerRef.current) === null || _messageListManagerRe === void 0 ? void 0 : _messageListManagerRe.attachListeners(messageListCallback); //setMessageList([]);
      // Fetch MessageList

      fetchMessages(messageListManagerRef === null || messageListManagerRef === void 0 ? void 0 : messageListManagerRef.current).then(function (messages) {
        if (messageList.length === 0 && messages.length === 0) {
          setDecoratorMessage(localize("NO_MESSAGES_FOUND"));
        } else {
          setMessageCount(messages.length);
          setMessageList(messages);
          setDecoratorMessage("");
          messageHandler(messages, true);
        }
      }).catch(function (error) {
        errorHandler(error);
        console.log(error);
        setDecoratorMessage(localize("SOMETHING_WRONG"));
      });
    }).catch(function (error) {
      errorHandler(error);
      setDecoratorMessage(localize("SOMETHING_WRONG"));
    });
  }); // Update MessageList on change of props


  _react.default.useEffect(function () {
    setnewMessage([]);

    if (messageTypes) {
      if (messageTypes.length === 0) {
        return messageCategoryRef.current = [], messageTypesRef.current = [], setDecoratorMessage(localize("NO_MESSAGE_TYPE_SET"));
      } else {
        messageTypesRef.current = messageTypes.map(function (value) {
          return value.type;
        });
        messageCategoryRef.current = (0, _toConsumableArray2.default)(new Set(messageTypes.map(function (value) {
          return value.category;
        })));

        if (excludeMessageTypes && excludeMessageTypes.length) {
          messageTypesRef.current.filter(function (val) {
            return !excludeMessageTypes.includes(val);
          });
        }
      }
    }

    messageListManagerRef.current = new _controller.MessageListManager(limit, user, group, onlyUnread, hideDeletedMessages, hideMessagesFromBlockedUsers, tags, messageTypesRef.current, messageCategoryRef.current);
    setMessageList([]);
    fetchMessages(messageListManagerRef === null || messageListManagerRef === void 0 ? void 0 : messageListManagerRef.current).then(function (messages) {
      if (messageList.length === 0 && messages.length === 0) {
        setDecoratorMessage(localize("NO_MESSAGES_FOUND"));
      } else {
        setMessageCount(messages.length);
        setMessageList(messages);
        setDecoratorMessage("");
      }

      messageHandler(messages, true);
    }).catch(function (error) {
      errorHandler(error);
      setDecoratorMessage(localize("SOMETHING_WRONG"));
    });
    return function () {
      if (messageListManagerRef && messageListManagerRef.current && typeof messageListManagerRef.current.removeListeners === "function") {
        var _messageListManagerRe2;

        (_messageListManagerRe2 = messageListManagerRef.current) === null || _messageListManagerRe2 === void 0 ? void 0 : _messageListManagerRe2.removeListeners();
      }
    };
  }, [limit, tags, onlyUnread, user, group, messageTypes, hideDeletedMessages, hideMessagesFromBlockedUsers]); //set receiver and receiver type


  _react.default.useEffect(function () {
    //set receiver and receiver type
    if (user && user.uid) {
      setChatWithType(_.ReceiverTypeConstants.user);
      setChatWith(user);
    } else if (group && group.guid) {
      setChatWithType(_.ReceiverTypeConstants.group);
      setChatWith(group);
    }
  }, []); //update receiver and receiver type


  _react.default.useEffect(function () {
    if (user && user.uid) {
      setChatWithType(_.ReceiverTypeConstants.user);
      setChatWith(user);
    } else if (group && group.guid) {
      setChatWithType(_.ReceiverTypeConstants.group);
      setChatWith(group);
    }
  }, [user, group, setChatWithType, setChatWith]);

  _react.default.useEffect(function () {
    var handler = handlers[callbackData === null || callbackData === void 0 ? void 0 : callbackData.name];

    if (!handler) {
      return false;
    }

    return handler.apply(void 0, (0, _toConsumableArray2.default)(callbackData === null || callbackData === void 0 ? void 0 : callbackData.args));
  }, [callbackData]);
};

exports.Hooks = Hooks;