"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchMessages = exports.Hooks = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = _interopRequireDefault(require("react"));
var _chat = require("@cometchat-pro/chat");
var _ = require("../..");
var _controller = require("./controller");
var _CometChatMessageTemplate = require("../CometChatMessageTemplate");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var fetchMessages = function fetchMessages(MessageListManager) {
  return new Promise(function (resolve, reject) {
    MessageListManager.fetchPreviousMessages().then(function (messageList) {
      return resolve(messageList);
    })["catch"](function (error) {
      return reject(error);
    });
  });
};
exports.fetchMessages = fetchMessages;
var Hooks = function Hooks(limit, user, group, excludeMessageTypes, onlyUnread, hideDeletedMessages, hideMessagesFromBlockedUsers, tags, messageTypes, loggedInUserRef, messageList, setMessageList, setDecoratorMessage, setChatWith, setChatWithType, messageHandler, messageListCallback, handlers, callbackData, messageTypesRef, messageCategoryRef, messageListManagerRef, localize, errorHandler, chatWith, chatWithType, setMessageCount, setnewMessage) {
  _react["default"].useEffect(function () {
    //fetching logged in user

    _chat.CometChat.getLoggedinUser().then(function (user) {
      var _messageListManagerRe;
      loggedInUserRef.current = _objectSpread({}, user);

      // 	// Setting MessageList ManagerRef if messageTypes is supplied by the user
      if (messageTypes) {
        if (messageTypes.length === 0) {
          return messageCategoryRef.current = [], messageTypesRef.current = [], setDecoratorMessage(localize("NO_MESSAGE_TYPE_SET"));
        } else {
          messageTypesRef.current = messageTypes.map(function (value) {
            return value.type;
          });
          messageCategoryRef.current = (0, _toConsumableArray2["default"])(new Set(messageTypes.map(function (value) {
            return value.category;
          })));
          if (excludeMessageTypes && excludeMessageTypes.length) {
            messageTypesRef.current.filter(function (val) {
              return !(excludeMessageTypes !== null && excludeMessageTypes !== void 0 && excludeMessageTypes.includes(val));
            });
          }
        }
      }
      // Setting MessageList ManagerRef by default
      else {
        var messageTemplateObject = (0, _CometChatMessageTemplate.getDefaultTypes)();
        messageTypesRef.current = messageTemplateObject.map(function (value) {
          return value.type;
        });
        messageCategoryRef.current = (0, _toConsumableArray2["default"])(new Set(messageTemplateObject.map(function (value) {
          return value.category;
        })));
        if (excludeMessageTypes && excludeMessageTypes.length) {
          messageTypesRef.current.filter(function (val) {
            return !(excludeMessageTypes !== null && excludeMessageTypes !== void 0 && excludeMessageTypes.includes(val));
          });
        }
      }
      messageListManagerRef.current = new _controller.MessageListManager(limit, user, group, onlyUnread, hideDeletedMessages, hideMessagesFromBlockedUsers, tags, messageTypesRef.current, messageCategoryRef.current);
      messageListManagerRef === null || messageListManagerRef === void 0 ? void 0 : (_messageListManagerRe = messageListManagerRef.current) === null || _messageListManagerRe === void 0 ? void 0 : _messageListManagerRe.attachListeners(messageListCallback);
      setMessageList([]);

      // Fetch MessageList
      fetchMessages(messageListManagerRef === null || messageListManagerRef === void 0 ? void 0 : messageListManagerRef.current).then(function (messages) {
        if (messageList.length === 0 && messages.length === 0) {
          setDecoratorMessage(localize("NO_MESSAGES_FOUND"));
        } else {
          setMessageCount(messages.length);
          setMessageList(messages);
          setDecoratorMessage("");
          messageHandler(messages, true);
        }
      })["catch"](function (error) {
        errorHandler(error);
        setDecoratorMessage(localize("SOMETHING_WRONG"));
      });
    })["catch"](function (error) {
      errorHandler(error);
      setDecoratorMessage(localize("SOMETHING_WRONG"));
    });
  }, []);

  // Update MessageList on change of props
  _react["default"].useEffect(function () {
    setnewMessage([]);
    if (messageTypes) {
      if (messageTypes.length === 0) {
        return messageCategoryRef.current = [], messageTypesRef.current = [], setDecoratorMessage(localize("NO_MESSAGE_TYPE_SET"));
      } else {
        messageTypesRef.current = messageTypes.map(function (value) {
          return value.type;
        });
        messageCategoryRef.current = (0, _toConsumableArray2["default"])(new Set(messageTypes.map(function (value) {
          return value.category;
        })));
        if (excludeMessageTypes && excludeMessageTypes.length) {
          messageTypesRef.current.filter(function (val) {
            return !(excludeMessageTypes !== null && excludeMessageTypes !== void 0 && excludeMessageTypes.includes(val));
          });
        }
      }
    }
    messageListManagerRef.current = new _controller.MessageListManager(limit, user, group, onlyUnread, hideDeletedMessages, hideMessagesFromBlockedUsers, tags, messageTypesRef.current, messageCategoryRef.current);
    setMessageList([]);
    fetchMessages(messageListManagerRef === null || messageListManagerRef === void 0 ? void 0 : messageListManagerRef.current).then(function (messages) {
      if (messageList.length === 0 && messages.length === 0) {
        setDecoratorMessage(localize("NO_MESSAGES_FOUND"));
      } else {
        setMessageCount(messages.length);
        setMessageList(messages);
        setDecoratorMessage("");
      }
      messageHandler(messages, true);
    })["catch"](function (error) {
      errorHandler(error);
      setDecoratorMessage(localize("SOMETHING_WRONG"));
    });
    return function () {
      if (messageListManagerRef && messageListManagerRef.current && typeof messageListManagerRef.current.removeListeners === "function") {
        var _messageListManagerRe2;
        (_messageListManagerRe2 = messageListManagerRef.current) === null || _messageListManagerRe2 === void 0 ? void 0 : _messageListManagerRe2.removeListeners();
      }
    };
  }, [limit, tags, onlyUnread, user, group, messageTypes, hideDeletedMessages, hideMessagesFromBlockedUsers]);

  //set receiver and receiver type
  _react["default"].useEffect(function () {
    //set receiver and receiver type
    if (user && user.uid) {
      setChatWithType(_.ReceiverTypeConstants.user);
      setChatWith(user);
    } else if (group && group.guid) {
      setChatWithType(_.ReceiverTypeConstants.group);
      setChatWith(group);
    }
  }, []);

  //update receiver and receiver type
  _react["default"].useEffect(function () {
    if (user && user.uid) {
      setChatWithType(_.ReceiverTypeConstants.user);
      setChatWith(user);
    } else if (group && group.guid) {
      setChatWithType(_.ReceiverTypeConstants.group);
      setChatWith(group);
    }
  }, [user, group, setChatWithType, setChatWith]);
  _react["default"].useEffect(function () {
    var handler = handlers[callbackData === null || callbackData === void 0 ? void 0 : callbackData.name];
    if (handler) return handler.apply(void 0, (0, _toConsumableArray2["default"])(callbackData === null || callbackData === void 0 ? void 0 : callbackData.args));
  }, [callbackData]);
};
exports.Hooks = Hooks;